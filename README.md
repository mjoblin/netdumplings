# netdumplings

netdumplings is a framework for distributed network packet sniffing.

See the [documentation](https://netdumplings.readthedocs.org) for more details,
and the [netmomo](https://github.com/mjoblin/netmomo) and
[packscape](https://github.com/mjoblin/packscape) sample Web applications
(dumpling eaters) which use netdumplings as their back-end.

## Distributed packet sniffing?

netdumplings allows you to run multiple packet sniffers on any number of hosts.
Those sniffers -- called **dumpling kitchens** -- pass any sniffed network
packets to your Python code for processing. Your Python code is implemeted as
classes called **dumpling chefs** which use the network packets to generate
**dumplings**. Dumpling contents are entirely up to you but they'll usually
describe the information contained in the sniffed network packets.

The dumplings created by the dumpling chefs are sent to a single **dumpling
hub**, which forwards them on to any connected **dumpling eaters** for display
or for any other sort of processing or visualization. Dumpling eaters can be
written in any language but netdumplings provides a convenience class for
writing them in Python.

Dumplings are just JSON data which are sent to and from the dumpling hub over
WebSockets.

The result looks something like this:

![overview](./docs/_static/overview.svg)

Note that you write the bits in green (the dumpling chefs and the dumpling
eaters) and netdumplings provides the rest. Also, even though the above shows
everything running on different hosts, you can run everything on the same host
if that better suits your needs.

## What's in the box?

netdumplings comes with:

* The packet sniffer kitchen `nd-sniff`
* The dumpling hub `nd-hub`
* Sample dumpling chefs in the `netdumplings.dumplingchefs` module
* Sample dumpling eaters `nd-print`, `nd-hubdetails`, and `nd-hubstatus`
* Classes to help you write your own chefs and eaters

## Try it out

netdumplings requires Python 3.5 or later.

To try netdumplings you don't need to write any of your own code. You can use
the sample dumpling chefs and dumpling eaters instead.

### Installation

To install netdumplings:

```
$ pip3 install netdumplings
```

### 1. Dumpling hub

First start the dumpling hub:

```
$ nd-hub
```

You should see something like this:

```
2018-01-20T22:40:27.416 INFO Dumpling hub initiated; waiting for connections
2018-01-20T22:40:27.417 INFO Dumplings in: ws://localhost:11347  out: ws://localhost:11348
```

The hub is now waiting for WebSocket connections from one or more sniffer
kitchens (to receive dumplings from) or eaters (to send dumplings to).

### 2. Sniffer kitchen

Now open another terminal and start a sniffer kitchen:

```
$ nd-sniff
```

You should see something like this:

```
2018-01-20T22:41:15.991 INFO default_kitchen: Starting network sniffer process
2018-01-20T22:41:15.992 INFO default_kitchen: Interface: en0
2018-01-20T22:41:15.992 INFO default_kitchen: Starting dumpling emitter process
2018-01-20T22:41:15.993 INFO default_kitchen: Requested chefs: all
2018-01-20T22:41:15.993 INFO default_kitchen: Chef modules: netdumplings.dumplingchefs
2018-01-20T22:41:15.993 INFO default_kitchen: Filter: tcp or udp or arp
2018-01-20T22:41:15.993 INFO default_kitchen: Chef poke interval (secs): 5.0
2018-01-20T22:41:15.993 INFO default_kitchen: Registering netdumplings.dumplingchefs.ARPChef with kitchen
2018-01-20T22:41:15.994 INFO default_kitchen: Registering netdumplings.dumplingchefs.DNSLookupChef with kitchen
2018-01-20T22:41:15.994 INFO default_kitchen: Registering netdumplings.dumplingchefs.PacketCountChef with kitchen
2018-01-20T22:41:15.994 INFO default_kitchen: Starting interval poker thread
2018-01-20T22:41:15.994 INFO default_kitchen: Connecting to the dumpling hub at ws://localhost:11347
2018-01-20T22:41:15.995 INFO default_kitchen: Starting sniffer thread
```

The sniffer kitchen will default to passing all sniffed packets to the dumpling
chefs defined in the `netdumplings.dumplingchefs` module. This includes
`ARPChef` (which reports ARP traffic), `DNSLookupChef` (which reports DNS
lookups), and `PacketCountChef` (which counts packets by protocol).

The dumplings created by the chefs are automatically sent to the dumpling hub.

You may need to specify a specific interface when starting the dumpling kithen:

```
$ nd-sniff --interface en0
```

### 3. Dumpling eater

Now open a third terminal and start a sample eater. This eater will display all
the dumplings generated by the dumpling chefs registered to the sniffer
kitchen.

```
$ nd-print
```

You should see something like this:

```
Connected to nd-hub at ws://localhost:11348
Waiting for dumplings...

2018-01-20T14:42:11.040829 [interval] PacketCountChef from default_kitchen

{
    "packet_counts": {
        "ARP": 4,
        "Ethernet": 7052,
        "IP": 7048,
        "Raw": 7046,
        "TCP": 6,
        "UDP": 7042
    }
}
```

### Additional dumpling eaters

netdumplings comes with two other dumpling eaters which can be used to monitor
`nd-hub`, called `nd-hubstatus` and `nd-hubdetails`:

`nd-hubstatus` continually prints summary status information from `nd-hub`:

```
$ nd-hubstatus

nd-hub status from ws://localhost:11348
2018-01-20 14:44:52  uptime: 00:04:25  dumplings in: 107  out: 92  kitchens: 1  eaters: 1
```

`nd-hubdetails` displays the contents of a single system status dumpling:

```
$ nd-hubdetails

Connected to nd-hub at ws://localhost:11348
Waiting for a SystemStatus dumpling...

{
    "dumpling_eater_count": 1,
    "dumpling_eaters": [
        {
            "info_from_eater": {
                "eater_name": "detailseater"
            },
            "info_from_hub": {
                "host": "::1",
                "port": 60807
            }
        }
    ],
    "dumpling_kitchen_count": 1,
    "dumpling_kitchens": [
        {
            "info_from_hub": {
                "host": "::1",
                "port": 60786
            },
            "info_from_kitchen": {
                "chefs": [
                    "netdumplings.dumplingchefs.ARPChef",
                    "netdumplings.dumplingchefs.DNSLookupChef",
                    "netdumplings.dumplingchefs.PacketCountChef"
                ],
                "filter": "tcp or udp or arp",
                "interface": "en0",
                "kitchen_name": "default_kitchen",
                "poke_interval": 5.0
            }
        }
    ],
    "server_uptime": 275.232823,
    "total_dumplings_in": 111,
    "total_dumplings_out": 95
}
```

## Writing your own chefs and eaters

To get the most use out of netdumplings you'll be writing your own **dumpling
chefs** in Python, which you register with one or more running instances of
`nd-sniff`.

You'll also write your own **dumpling eaters** (perhaps using the DumplingEater
helper class that comes with netdumplings). Dumpling eaters are just WebSocket
clients which receive JSON dumpling payloads so you can also write them in any
other language.

See the [full documentation](https://netdumplings.readthedocs.org) for more but
here's an example of each.

### Example dumpling chef

To create a dumpling chef you subclass `netdumplings.DumplingChef` and
implement one or both of `packet_handler()` and `interval_handler()`. Whatever
is returned from the handler is automatically packaged into a dumpling by
`nd-sniff` and sent to `nd-hub`.

Dumpling chefs can be housed in three places:
 
1. Python modules accessible via `PYTHONPATH` (e.g. `module.with.chefs`)
1. Python modules located under the directory where `nd-sniff` is run from
1. Standalone Python files (e.g. `/path/to/chefs.py`)

You tell `nd-sniff` where to find dumpling chefs using the `--chef-module`
flag.

The following dumpling chef creates a dumpling for every DNS lookup.

```python
import time
import netdumplings

class DNSLookupChef(netdumplings.DumplingChef):
    def packet_handler(self, packet):
        # The incoming packet is a scapy packet object.
        # https://scapy.readthedocs.io

        # Ignore packets that we don't care about.
        if not packet.haslayer('DNS'):
            return

        # Determine the name of the host that was looked up.
        dns_query = packet.getlayer('DNS')
        query = dns_query.fields['qd']
        hostname = query.qname.decode('utf-8')

        # Generate and return a dumpling payload. This will be
        # automatically forwarded to all the eaters.
        dumpling_payload = {
            'lookup': {
                'hostname': hostname,
                'when': time.time(),
            }
        }

        return dumpling_payload
```

If you put the above chef code into a file in your home directory called
`my_chefs.py` then you can tell `nd-sniff` where to find it with:

```
$ nd-sniff --chef-module ~/my_chefs.py
```

### Example dumpling eater

To create a dumpling eater with Python you subclass
`netdumplings.DumplingEater` and implement `on_dumpling()`. All eaters will
receive all dumplings being sent out from `nd-hub`.

The DumplingEater handlers, like `on_dumpling`, are async methods so you need
to define them with the `async` keyword.

The following dumpling eater prints the payload of every dumpling sent out from
`nd-hub`.

```python
import json
import netdumplings

class PrinterEater(netdumplings.DumplingEater):
    async def on_connect(self, hub_uri, websocket):
        print('Connected to nd-hub at {0}'.format(hub_uri))
        print('Waiting for dumplings...\n')

    async def on_dumpling(self, dumpling):
        # The given dumpling is a netdumplings.Dumpling instance.
        dumpling_printable = json.dumps(dumpling.payload, indent=4)
        print('{}\n'.format(dumpling_printable))


def dumpling_printer():
    eater = PrinterEater()
    eater.run()


if __name__ == '__main__':
    dumpling_printer()
```
